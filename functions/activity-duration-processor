#!/usr/bin/env nu

# Activity Duration Processor
# Automatically calculates and inserts durations for any activity time range entries
# Processes entries like "s:: 0025-0755" -> "s:: 7hr 30min 0025-0755"
# Works with any activity code (single or multi-letter): w::, e::, m::, test::, etc.
# Supports shorthand: "p:: 0845-55" -> "p:: 10min 0845-0855"
# Created: 2025-09-07, Expanded: 2025-09-09

def main [file_path?: string] {
    let target_file = if ($file_path | is-empty) {
        # If no file specified, find recently modified .md files
        let files = (glob $"($env.HOME)/Obsidian.nosync/Forge/**/*.md")
        
        if ($files | length) == 0 {
            print "No markdown files found in vault"
            return
        }
        
        # Process files modified in the last 5 minutes
        let recent_files = ($files 
            | each { |file| 
                let stats = ($file | path expand | stat)
                {path: $file, modified: $stats.modified}
            }
            | where {|it| $it.modified > ((date now) - 5min)}
            | get path)
        
        if ($recent_files | length) == 0 {
            print "No recently modified markdown files found"
            return
        }
        
        # Process all recent files
        for file in $recent_files {
            print $"Processing: ($file)"
            # Recursively call self with each file
            ^activity-duration-processor $file
        }
        return  # Exit after processing all files
    } else {
        $file_path
    }
    
    if not ($target_file | path exists) {
        print $"File not found: ($target_file)"
        return
    }
    
    # Read file content with retry logic for file system reliability
    let content = (try {
        open $target_file
    } catch { |err|
        # Retry once after brief delay if file read fails
        sleep 50ms
        open $target_file
    })
    let lines = ($content | lines)
    
    let processed_lines = ($lines | each { |line|
        # Look for ALL time range patterns in the line (handles nested entries)
        # Match time patterns (HHMM) but NOT dates (YYYY-MM-DD)
        # Only match 4-digit patterns where first 2 digits are 00-23 (hours)
        let time_range_matches = ($line | parse --regex '([0-2]\d[0-5]\d)-(\d{2,4})')
        
        if ($time_range_matches | length) > 0 {
            mut current_line = $line
            
            # Process each time pattern found in the line
            for match in $time_range_matches {
                let start_time = ($match | get capture0)
                let end_time_raw = ($match | get capture1)
                let time_range_text = $"($start_time)-($end_time_raw)"
                
                # Skip this pattern if it's already processed (has duration before it)
                # Look for pattern like "15min 1430-45" or "2hr 30min 0900-30"
                # Only match actual duration units: min, hr, sec, hour, minute, second
                let has_duration = (($current_line | str contains $"min ($start_time)-($end_time_raw)") or ($current_line | str contains $"hr ($start_time)-($end_time_raw)") or ($current_line | str contains $"sec ($start_time)-($end_time_raw)"))
                if $has_duration {
                    continue  # This specific pattern already has duration, skip it
                }
                
                # Handle both full HHMM and shorthand MM formats for end time
                let end_time = if ($end_time_raw | str length) == 2 {
                    # Shorthand: expand 2-digit end time to HHMM
                    let start_hour = ($start_time | str substring 0..<2 | into int)
                    let start_min = ($start_time | str substring 2..<4 | into int)
                    let end_min = ($end_time_raw | into int)
                    
                    if $end_min <= $start_min {
                        # Next hour
                        let end_hour_raw = $start_hour + 1
                        let end_hour = if $end_hour_raw >= 24 { $end_hour_raw - 24 } else { $end_hour_raw }
                        $"(if $end_hour < 10 { $"0($end_hour)" } else { $end_hour })(if $end_min < 10 { $"0($end_min)" } else { $end_min })"
                    } else {
                        # Same hour
                        $"(if $start_hour < 10 { $"0($start_hour)" } else { $start_hour })(if $end_min < 10 { $"0($end_min)" } else { $end_min })"
                    }
                } else if ($end_time_raw | str length) == 4 {
                    # Full format
                    $end_time_raw
                } else {
                    "" # Invalid
                }
                
                if ($end_time | str length) == 4 {
                    # Convert HHMM to HH:MM format for datetime parsing
                    let start_formatted = ($start_time | str substring 0..<2) + ":" + ($start_time | str substring 2..<4)
                    let end_formatted = ($end_time | str substring 0..<2) + ":" + ($end_time | str substring 2..<4)
                    
                    try {
                        # Use Nushell's native datetime parsing and calculation
                        let start_dt = ($start_formatted | into datetime)
                        let end_dt = ($end_formatted | into datetime)
                        
                        # Calculate duration (handle overnight)
                        let duration = if $end_dt < $start_dt {
                            ($end_dt + 1day) - $start_dt
                        } else {
                            $end_dt - $start_dt
                        }
                        
                        # Format as Nushell duration string
                        let duration_str = ($duration | to text)
                        
                        # Replace the time pattern with duration + expanded time in current line
                        $current_line = ($current_line | str replace $time_range_text $"($duration_str) ($start_time)-($end_time)")
                    } catch {
                        # Continue with next match if this one fails
                    }
                }
            }
            
            $current_line
        } else {
            $line  # No time patterns found
        }
    })
    
    let processed_content = ($processed_lines | str join "\n")
    
    # Only write if content changed
    if $processed_content != $content {
        $processed_content | save --force $target_file
    }
}